<script>
const { createApp, ref, reactive, onMounted, onUnmounted, nextTick, watch, toRaw } = Vue;

const WORKER_CODE = `
    self.onmessage = function(e) {
        const { id, type, data } = e.data;
        if (type === 'CALCULATE') {
            const { candles, indicators } = data;
            const results = {};
            
            for (const ind of indicators) {
                try {
                    if (ind === 'ma') {
                        results.ma = [
                            calculateSMA(candles, 7),
                            calculateSMA(candles, 25),
                            calculateSMA(candles, 99)
                        ];
                    } else if (ind === 'ema') {
                        results.ema = [
                            calculateEMA(candles, 7),
                            calculateEMA(candles, 25),
                            calculateEMA(candles, 99)
                        ];
                    } else if (ind === 'boll') {
                        results.boll = calculateBollingerBands(candles, 20, 2);
                    } else if (ind === 'sar') {
                        results.sar = calculateSAR(candles);
                    } else if (ind === 'supertrend') {
                        results.supertrend = calculateSuperTrend(candles);
                    } else if (ind === 'sr') {
                        results.sr = calculateSupportResistance(candles);
                    } else if (ind === 'macd') {
                        results.macd = calculateMACD(candles, 12, 26, 9);
                    } else if (ind === 'kdj') {
                        results.kdj = calculateKDJ(candles, 9, 3, 3);
                    } else if (ind === 'rsi') {
                        results.rsi = calculateRSI(candles, 14);
                    } else if (ind === 'stochrsi') {
                        results.stochrsi = calculateStochRSI(candles, 14, 14, 3, 3);
                    } else if (ind === 'cci') {
                        results.cci = calculateCCI(candles, 20);
                    } else if (ind === 'dmi') {
                        results.dmi = calculateDMI(candles, 14);
                    } else if (ind === 'wr') {
                        results.wr = calculateWR(candles, 14);
                    } else if (ind === 'obv') {
                        results.obv = calculateOBV(candles);
                    } else if (ind === 'trix') {
                        results.trix = calculateTRIX(candles, 12);
                    } else if (ind === 'roc') {
                        results.roc = calculateROC(candles, 12);
                    } else if (ind === 'mtm') {
                        results.mtm = calculateMTM(candles, 12);
                    } else if (ind === 'dma') {
                        results.dma = calculateDMA(candles, 10, 50);
                    } else if (ind === 'vr') {
                        results.vr = calculateVR(candles, 26);
                    } else if (ind === 'brar') {
                        results.brar = calculateBRAR(candles, 26);
                    } else if (ind === 'psy') {
                        results.psy = calculatePSY(candles, 12);
                    }
                } catch (err) {
                    console.error('Worker calculation error:', ind, err);
                }
            }
            self.postMessage({ id, type: 'RESULT', results });
        }
    };

    function calculateSMA(candles, period) {
        const result = [];
        for (let i = 0; i < candles.length; i++) {
            if (i < period - 1) continue;
            let sum = 0;
            for (let j = 0; j < period; j++) sum += candles[i - j].close;
            result.push({ time: candles[i].time, value: sum / period });
        }
        return result;
    }

    function calculateEMA(candles, period) {
        const result = [];
        const k = 2 / (period + 1);
        let ema = candles[0].close;
        result.push({ time: candles[0].time, value: ema });
        for (let i = 1; i < candles.length; i++) {
            ema = (candles[i].close - ema) * k + ema;
            result.push({ time: candles[i].time, value: ema });
        }
        return result;
    }

    function calculateBollingerBands(candles, period, stdDevMultiplier) {
        const upper = [];
        const middle = [];
        const lower = [];
        for (let i = 0; i < candles.length; i++) {
            if (i < period - 1) continue;
            let sum = 0;
            for (let j = 0; j < period; j++) sum += candles[i - j].close;
            const sma = sum / period;
            let sumSquaredDiff = 0;
            for (let j = 0; j < period; j++) sumSquaredDiff += Math.pow(candles[i - j].close - sma, 2);
            const stdDev = Math.sqrt(sumSquaredDiff / period);
            middle.push({ time: candles[i].time, value: sma });
            upper.push({ time: candles[i].time, value: sma + stdDev * stdDevMultiplier });
            lower.push({ time: candles[i].time, value: sma - stdDev * stdDevMultiplier });
        }
        return { upper, middle, lower };
    }

    function calculateSAR(candles) {
        const result = [];
        if (candles.length < 2) return result;
        let af = 0.02, maxAf = 0.2, isLong = true;
        let sar = candles[0].low, ep = candles[0].high;
        for (let i = 1; i < candles.length; i++) {
            const prevSar = sar;
            sar = prevSar + af * (ep - prevSar);
            if (isLong) {
                if (candles[i].low < sar) {
                    isLong = false; sar = ep; ep = candles[i].low; af = 0.02;
                } else {
                    if (candles[i].high > ep) { ep = candles[i].high; af = Math.min(af + 0.02, maxAf); }
                }
            } else {
                if (candles[i].high > sar) {
                    isLong = true; sar = ep; ep = candles[i].high; af = 0.02;
                } else {
                    if (candles[i].low < ep) { ep = candles[i].low; af = Math.min(af + 0.02, maxAf); }
                }
            }
            result.push({ time: candles[i].time, value: sar });
        }
        return result;
    }

    function calculateSuperTrend(candles, period = 10, multiplier = 3) {
        const result = [];
        if (candles.length < period) return result;
        const trs = [];
        for(let i = 1; i < candles.length; i++) {
            const high = candles[i].high, low = candles[i].low, prevClose = candles[i-1].close;
            trs.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
        }
        let atr = trs.slice(0, period).reduce((a,b) => a+b, 0) / period;
        let upperBand = (candles[period].high + candles[period].low) / 2 + multiplier * atr;
        let lowerBand = (candles[period].high + candles[period].low) / 2 - multiplier * atr;
        let inUptrend = true;
        for (let i = period; i < candles.length; i++) {
            const currHigh = candles[i].high, currLow = candles[i].low, currClose = candles[i].close, prevClose = candles[i-1].close;
            if (i > period) {
                const tr = Math.max(currHigh - currLow, Math.abs(currHigh - prevClose), Math.abs(currLow - prevClose));
                atr = (atr * (period - 1) + tr) / period;
            }
            let currUpperBand = (currHigh + currLow) / 2 + multiplier * atr;
            let currLowerBand = (currHigh + currLow) / 2 - multiplier * atr;
            if (inUptrend) {
                if (currLowerBand < lowerBand) currLowerBand = lowerBand;
                if (currClose < lowerBand) { inUptrend = false; upperBand = currUpperBand; } else { lowerBand = currLowerBand; }
            } else {
                if (currUpperBand > upperBand) currUpperBand = upperBand;
                if (currClose > upperBand) { inUptrend = true; lowerBand = currLowerBand; } else { upperBand = currUpperBand; }
            }
            result.push({ time: candles[i].time, value: inUptrend ? lowerBand : upperBand, color: inUptrend ? '#26a69a' : '#ef5350' });
        }
        return result;
    }

    function calculateSupportResistance(candles) {
        const support = [], resistance = [];
        let lastHigh = null;
        let lastLow = null;
        
        for (let i = 0; i < candles.length; i++) {
            if (i >= 4) {
                const idx = i - 2;
                const center = candles[idx];
                const l1 = candles[idx-1];
                const l2 = candles[idx-2];
                const r1 = candles[idx+1];
                const r2 = candles[i];
                
                if (center.high > l1.high && center.high > l2.high && center.high > r1.high && center.high > r2.high) {
                    lastHigh = center.high;
                }
                if (center.low < l1.low && center.low < l2.low && center.low < r1.low && center.low < r2.low) {
                    lastLow = center.low;
                }
            }
            
            if (lastHigh !== null) resistance.push({ time: candles[i].time, value: lastHigh });
            if (lastLow !== null) support.push({ time: candles[i].time, value: lastLow });
        }
        return { support, resistance };
    }

    function calculateMACD(candles, fastPeriod, slowPeriod, signalPeriod) {
        const emaFast = calculateEMA(candles, fastPeriod);
        const emaSlow = calculateEMA(candles, slowPeriod);
        const difData = [], deaData = [], histogramData = [];
        const minLen = Math.min(emaFast.length, emaSlow.length);
        const offsetFast = emaFast.length - minLen, offsetSlow = emaSlow.length - minLen;
        const difValues = [];
        for (let i = 0; i < minLen; i++) {
            const val = emaFast[i + offsetFast].value - emaSlow[i + offsetSlow].value;
            const time = emaFast[i + offsetFast].time;
            difValues.push({ time, value: val });
            difData.push({ time, value: val });
        }
        let dea = difValues[0].value;
        const k = 2 / (signalPeriod + 1);
        deaData.push({ time: difValues[0].time, value: dea });
        histogramData.push({ time: difValues[0].time, value: difValues[0].value - dea, color: (difValues[0].value - dea) >= 0 ? '#26a69a' : '#ef5350' });
        for (let i = 1; i < difValues.length; i++) {
            dea = (difValues[i].value - dea) * k + dea;
            deaData.push({ time: difValues[i].time, value: dea });
            const hist = difValues[i].value - dea;
            histogramData.push({ time: difValues[i].time, value: hist, color: hist >= 0 ? '#26a69a' : '#ef5350' });
        }
        return { dif: difData, dea: deaData, histogram: histogramData };
    }

    function calculateRSI(candles, period) {
        const result = [];
        if (candles.length < period + 1) return result;
        let gains = 0, losses = 0;
        for (let i = 1; i <= period; i++) {
            const change = candles[i].close - candles[i-1].close;
            if (change > 0) gains += change; else losses -= change;
        }
        let avgGain = gains / period, avgLoss = losses / period;
        for (let i = period + 1; i < candles.length; i++) {
            const change = candles[i].close - candles[i-1].close;
            let gain = change > 0 ? change : 0, loss = change < 0 ? -change : 0;
            avgGain = (avgGain * (period - 1) + gain) / period;
            avgLoss = (avgLoss * (period - 1) + loss) / period;
            const rs = avgGain / avgLoss;
            result.push({ time: candles[i].time, value: 100 - (100 / (1 + rs)) });
        }
        return result;
    }

    function calculateKDJ(candles, n, m1, m2) {
        const kData = [], dData = [], jData = [];
        let k = 50, d = 50;
        for (let i = 0; i < candles.length; i++) {
            if (i < n - 1) continue;
            let low = candles[i].low, high = candles[i].high;
            for (let j = 0; j < n; j++) {
                if (candles[i-j].low < low) low = candles[i-j].low;
                if (candles[i-j].high > high) high = candles[i-j].high;
            }
            const rsv = (candles[i].close - low) / (high - low) * 100;
            k = (m1 - 1) / m1 * k + 1 / m1 * rsv;
            d = (m2 - 1) / m2 * d + 1 / m2 * k;
            kData.push({ time: candles[i].time, value: k });
            dData.push({ time: candles[i].time, value: d });
            jData.push({ time: candles[i].time, value: 3 * k - 2 * d });
        }
        return { k: kData, d: dData, j: jData };
    }

    function calculateCCI(candles, period) {
        const result = [];
        if (candles.length < period) return result;
        const tps = candles.map(c => (c.high + c.low + c.close) / 3);
        for (let i = period - 1; i < candles.length; i++) {
            let sumTp = 0;
            for (let j = 0; j < period; j++) sumTp += tps[i-j];
            const maTp = sumTp / period;
            let sumMd = 0;
            for (let j = 0; j < period; j++) sumMd += Math.abs(tps[i-j] - maTp);
            const md = sumMd / period;
            result.push({ time: candles[i].time, value: (tps[i] - maTp) / (0.015 * md) });
        }
        return result;
    }

    function calculateWR(candles, period) {
        const result = [];
        for (let i = period - 1; i < candles.length; i++) {
            let highest = -Infinity, lowest = Infinity;
            for (let j = 0; j < period; j++) {
                if (candles[i-j].high > highest) highest = candles[i-j].high;
                if (candles[i-j].low < lowest) lowest = candles[i-j].low;
            }
            result.push({ time: candles[i].time, value: (highest - candles[i].close) / (highest - lowest) * -100 });
        }
        return result;
    }

    function calculateOBV(candles) {
        const result = [];
        let obv = 0;
        result.push({ time: candles[0].time, value: obv });
        for (let i = 1; i < candles.length; i++) {
            if (candles[i].close > candles[i-1].close) obv += candles[i].volume;
            else if (candles[i].close < candles[i-1].close) obv -= candles[i].volume;
            result.push({ time: candles[i].time, value: obv });
        }
        return result;
    }

    function calculateROC(candles, period) {
        const result = [];
        for (let i = period; i < candles.length; i++) {
            result.push({ time: candles[i].time, value: ((candles[i].close - candles[i-period].close) / candles[i-period].close) * 100 });
        }
        return result;
    }

    function calculateMTM(candles, period) {
        const result = [];
        for (let i = period; i < candles.length; i++) {
            result.push({ time: candles[i].time, value: candles[i].close - candles[i-period].close });
        }
        return result;
    }

    function calculatePSY(candles, period) {
        const result = [];
        for (let i = period; i < candles.length; i++) {
            let upCount = 0;
            for (let j = 0; j < period; j++) {
                if (candles[i-j].close > candles[i-j-1].close) upCount++;
            }
            result.push({ time: candles[i].time, value: (upCount / period) * 100 });
        }
        return result;
    }

    function calculateDMI(candles, period) { return { pdi: [], mdi: [], adx: [] }; }
    function calculateStochRSI(candles, rsiPeriod, stochPeriod, kPeriod, dPeriod) { return { k: [], d: [] }; }
    function calculateTRIX(candles, period) { return []; }
    function calculateDMA(candles, shortPeriod, longPeriod) { return { ddd: [], ama: [] }; }
    function calculateVR(candles, period) { return []; }
    function calculateBRAR(candles, period) { return { br: [], ar: [] }; }
`;

createApp({
    delimiters: ['[[', ']]'],
    setup() {
        const currentSymbol = ref('{{ inst_id }}');
        const currentBar = ref('{{ bar }}');
        const currentSource = ref('{{ source }}');
        const isAutoRefresh = ref(true);
        const isLoading = ref(true);
        const chartRef = ref(null);
        
        const ticker = reactive({
            last: '--', open24h: '--', high24h: '--', low24h: '--', vol24h: '--', changePercent: '--', isUp: true
        });

        const error = reactive({ show: false, message: '' });
        const chartError = reactive({ show: false, message: '', detail: '' });

        const indicators = reactive({
            vol: { enabled: true, series: null },
            ma: { enabled: false, series: [] },
            ema: { enabled: false, series: [] },
            boll: { enabled: false, series: [] },
            sar: { enabled: false, series: [] },
            supertrend: { enabled: false, series: [] },
            sr: { enabled: false, series: [] },
            activeSubIndicator: 'none',
            subSeries: []
        });

        const settings = reactive({
            colorScheme: localStorage.getItem('geneticgrid_color_scheme') || 'green-up',
            currency: localStorage.getItem('geneticgrid_currency') || 'USDT',
            showModal: false
        });

        const exchangeRates = reactive({
            'USDT': 1, 'USDC': 1, 'USD': 1,
            'CNY': 7.25, 'EUR': 0.95, 'GBP': 0.79, 'JPY': 150, 'KRW': 1400,
            'HKD': 7.8, 'AUD': 1.5, 'CAD': 1.4, 'CHF': 0.88, 'SGD': 1.34,
            'INR': 84, 'RUB': 105
        });

        const fetchExchangeRates = async () => {
            try {
                const res = await fetch('https://open.er-api.com/v6/latest/USD');
                const data = await res.json();
                if (data && data.rates) {
                    Object.keys(exchangeRates).forEach(key => {
                        if (key !== 'USDT' && key !== 'USDC' && key !== 'USD' && data.rates[key]) {
                            exchangeRates[key] = data.rates[key];
                        }
                    });
                }
                if (settings.currency !== 'USDT' && settings.currency !== 'USD' && settings.currency !== 'USDC') {
                    updateChartData();
                    loadTicker();
                }
            } catch (e) {
                console.warn('获取实时汇率失败，使用默认汇率');
            }
        };

        const getRate = () => exchangeRates[settings.currency] || 1;
        const convertPrice = (price) => {
            if (price === undefined || price === null) return 0;
            return price * getRate();
        };
        
        const moreTimeframe = ref('');
        const customInterval = ref('');
        const showCustomInterval = ref(false);
        
        // Drawing Tools State
        const drawingCanvas = ref(null);
        const currentTool = ref('cursor');
        const drawings = reactive([]);
        const currentDrawing = ref(null);
        const isDrawingToolbarExpanded = ref(false);
        const parallelLevels = ref(2);
        const showToolSettings = ref(false);
        const draggingState = reactive({ drawing: null, pointIndex: -1, isDragging: false });

        const mainIndicatorsConfig = {
            ma: { label: 'MA (移动平均线)', title: 'Moving Average' },
            ema: { label: 'EMA (指数移动平均)', title: 'Exponential Moving Average' },
            boll: { label: 'BOLL (布林带)', title: 'Bollinger Bands' },
            sar: { label: 'SAR (抛物线转向)', title: 'Parabolic SAR' },
            supertrend: { label: 'SuperTrend', title: 'SuperTrend' },
            sr: { label: 'S/R (支撑压力)', title: 'Support & Resistance' }
        };

        const subIndicatorsConfig = {
            none: { label: '无' },
            macd: { label: 'MACD', title: 'Moving Average Convergence Divergence' },
            kdj: { label: 'KDJ', title: 'Stochastic Oscillator' },
            rsi: { label: 'RSI', title: 'Relative Strength Index' },
            stochrsi: { label: 'StochRSI', title: 'Stochastic RSI' },
            cci: { label: 'CCI', title: 'Commodity Channel Index' },
            dmi: { label: 'DMI', title: 'Directional Movement Index' },
            wr: { label: 'WR', title: 'Williams %R' },
            obv: { label: 'OBV', title: 'On Balance Volume' },
            trix: { label: 'TRIX', title: 'Triple Exponential Average' },
            roc: { label: 'ROC', title: 'Rate of Change' },
            mtm: { label: 'MTM', title: 'Momentum' },
            dma: { label: 'DMA', title: 'Different of Moving Average' },
            vr: { label: 'VR', title: 'Volume Ratio' },
            brar: { label: 'BRAR', title: 'BRAR' },
            psy: { label: 'PSY', title: 'Psychological Line' }
        };

        let chart = null;
        let candleSeries = null;
        let volumeSeries = null;
        let highlightSeries = null;
        let allCandles = [];
        let oldestTimestamp = null;
        let newestTimestamp = null;
        let hasMoreData = true;
        let hasNewerData = true;
        let isLoadingMore = false;
        let isLoadingNewer = false;
        let indicatorWorker = null;
        let workerTaskCounter = 0;
        let refreshInterval = null;
        let isTooltipLocked = false;
        let lockedCandleTime = null;

        // Drawing Tools Logic
        const setTool = (tool) => {
            if (currentTool.value === tool && tool !== 'delete') {
                if (tool === 'parallel') {
                    showToolSettings.value = !showToolSettings.value;
                }
                return;
            }

            currentTool.value = tool;
            currentDrawing.value = null;
            
            if (tool === 'parallel') {
                showToolSettings.value = true;
            } else {
                showToolSettings.value = false;
            }

            if (chartRef.value) {
                if (tool === 'cursor') chartRef.value.style.cursor = 'default';
                else if (tool === 'delete') chartRef.value.style.cursor = 'pointer'; // Or specific delete cursor
                else chartRef.value.style.cursor = 'crosshair';
            }
            renderDrawings();
        };

        const toggleDeleteMode = () => {
            if (currentTool.value === 'delete') {
                if (confirm('确定要删除所有画线吗？')) {
                    clearDrawings();
                    setTool('cursor');
                }
            } else {
                setTool('delete');
            }
        };

        const clearDrawings = () => {
            drawings.length = 0;
            currentDrawing.value = null;
            renderDrawings();
        };

        const pointToLogical = (point) => {
            if (!chart || !candleSeries) return null;
            const time = chart.timeScale().coordinateToTime(point.x);
            const price = candleSeries.coordinateToPrice(point.y);
            if (time === null || price === null) return null;
            return { time, price };
        };

        const findNearestTime = (targetTime) => {
            if (allCandles.length === 0) return null;
            if (targetTime < allCandles[0].time) return allCandles[0].time;
            if (targetTime > allCandles[allCandles.length - 1].time) return allCandles[allCandles.length - 1].time;

            let left = 0;
            let right = allCandles.length - 1;
            let closest = allCandles[0].time;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const midTime = allCandles[mid].time;
                if (midTime === targetTime) return midTime;
                if (midTime < targetTime) {
                    closest = midTime;
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            return closest;
        };

        const logicalToPoint = (logical) => {
            if (!chart || !candleSeries) return null;
            let x = chart.timeScale().timeToCoordinate(logical.time);
            if (x === null) {
                const nearest = findNearestTime(logical.time);
                if (nearest !== null) {
                    x = chart.timeScale().timeToCoordinate(nearest);
                }
            }
            const y = candleSeries.priceToCoordinate(logical.price);
            if (x === null || y === null) return null;
            return { x, y };
        };

        const distToSegment = (p, v, w) => {
            const l2 = (v.x - w.x) ** 2 + (v.y - w.y) ** 2;
            if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (v.x + t * (w.x - v.x)), p.y - (v.y + t * (w.y - v.y)));
        };

        const distToRay = (p, v, w) => {
             const dx = w.x - v.x;
             const dy = w.y - v.y;
             const l2 = dx*dx + dy*dy;
             if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
             let t = ((p.x - v.x) * dx + (p.y - v.y) * dy) / l2;
             t = Math.max(0, t);
             const projX = v.x + t * dx;
             const projY = v.y + t * dy;
             return Math.hypot(p.x - projX, p.y - projY);
        };

        const isHit = (drawing, point) => {
            const threshold = 5;
            const points = drawing.points.map(p => logicalToPoint(p));
            if (points.some(p => p === null)) return false;
            
            if (drawing.type === 'line') {
                return distToSegment(point, points[0], points[1]) < threshold;
            } else if (drawing.type === 'ray') {
                return distToRay(point, points[0], points[1]) < threshold;
            } else if (drawing.type === 'horizontal') {
                return Math.abs(point.y - points[0].y) < threshold;
            } else if (drawing.type === 'fib') {
                const y1 = points[0].y;
                const y2 = points[1].y;
                const diff = y2 - y1;
                const levels = [0, 1, 1.618, 2.618, 4.236, -1, -1.618, -2.618, -4.236];
                return levels.some(level => Math.abs(point.y - (y1 + diff * level)) < threshold);
            } else if (drawing.type === 'parallel') {
                const y1 = points[0].y;
                const y2 = points[1].y;
                const diff = y2 - y1;
                const levels = drawing.levels || 2;
                for (let i = -levels; i <= levels; i++) {
                    if (Math.abs(point.y - (y1 + diff * i)) < threshold) return true;
                }
                return false;
            }
            return false;
        };

        const handleDeleteClick = (point) => {
            for (let i = drawings.length - 1; i >= 0; i--) {
                if (isHit(drawings[i], point)) {
                    drawings.splice(i, 1);
                    renderDrawings();
                    return;
                }
            }
        };

        const handleDrawingClick = (param) => {
            if (currentTool.value === 'cursor' || !param || !param.point) return;
            const point = param.point;
            const logical = pointToLogical(point);
            if (!logical) return;

            if (!currentDrawing.value) {
                // Start new drawing
                currentDrawing.value = {
                    type: currentTool.value,
                    points: [logical]
                };
                
                if (currentTool.value === 'horizontal') {
                    drawings.push({ ...currentDrawing.value });
                    currentDrawing.value = null;
                } else if (currentTool.value === 'parallel') {
                    currentDrawing.value.levels = parallelLevels.value;
                }
            } else {
                // Finish drawing
                currentDrawing.value.points.push(logical);
                drawings.push({ ...currentDrawing.value });
                currentDrawing.value = null;
            }
            renderDrawings();
        };

        const handleDrawingMove = (param) => {
            if (!currentDrawing.value || !param || !param.point) return;
            const point = param.point;
            const logical = pointToLogical(point);
            if (!logical) return;
            
            // Update preview
            renderDrawings(logical);
        };

        const getCanvasPoint = (e) => {
            const rect = drawingCanvas.value.getBoundingClientRect();
            return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        };

        const renderDrawings = (previewPoint = null) => {
            if (!drawingCanvas.value || !chart) return;
            const ctx = drawingCanvas.value.getContext('2d');
            const { width, height } = drawingCanvas.value;
            ctx.clearRect(0, 0, width, height);

            const drawPriceLabel = (price, y) => {
                const formatNum = (num) => num >= 1000 ? num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}) : (num >= 1 ? num.toFixed(4) : num.toPrecision(4));
                const text = formatNum(price);
                
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const padding = 6;
                const boxHeight = 20;
                const boxWidth = textWidth + padding * 2;
                const boxX = width - boxWidth;
                const boxY = y - boxHeight / 2;

                ctx.fillStyle = '#2962FF';
                ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
                
                ctx.fillStyle = '#ffffff';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, boxX + padding, y);
            };

            const drawHandle = (x, y) => {
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fillStyle = '#ffffff';
                ctx.fill();
                ctx.strokeStyle = '#2962FF';
                ctx.lineWidth = 1;
                ctx.stroke();
            };

            const drawShape = (drawing, overrideLastPoint = null) => {
                const points = drawing.points.map(p => logicalToPoint(p));
                if (overrideLastPoint) {
                    const p = logicalToPoint(overrideLastPoint);
                    if (p) points.push(p);
                }
                
                if (points.some(p => p === null)) return;

                ctx.strokeStyle = '#2962FF';
                ctx.lineWidth = 2;
                ctx.beginPath();

                if (drawing.type === 'line') {
                    if (points.length < 2) return;
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.stroke();
                } else if (drawing.type === 'ray') {
                    if (points.length < 2) return;
                    ctx.moveTo(points[0].x, points[0].y);
                    const dx = points[1].x - points[0].x;
                    const dy = points[1].y - points[0].y;
                    const slope = dy / dx;
                    let endX, endY;
                    if (dx > 0) endX = width; else endX = 0;
                    endY = points[0].y + slope * (endX - points[0].x);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                } else if (drawing.type === 'horizontal') {
                    if (points.length < 1) return;
                    ctx.moveTo(0, points[0].y);
                    ctx.lineTo(width, points[0].y);
                    ctx.stroke();
                    drawPriceLabel(drawing.points[0].price, points[0].y);
                } else if (drawing.type === 'fib') {
                    if (points.length < 2) return;
                    const y1 = points[0].y;
                    const y2 = points[1].y;
                    const diff = y2 - y1;
                    
                    const price1 = candleSeries.coordinateToPrice(y1);
                    const colors = getColors();

                    const levels = [0, 1, 1.618, 2.618, 4.236, -1, -1.618, -2.618, -4.236];
                    levels.forEach(level => {
                        const y = y1 + diff * level;
                        ctx.beginPath();
                        ctx.lineWidth = (level === 0) ? 2 : 1;
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y); 
                        ctx.stroke();
                        
                        const price = candleSeries.coordinateToPrice(y);
                        let text = '';
                        let color = '#d1d4dc';
                        
                        if (price !== null && price1 !== null && price1 !== 0) {
                            const change = ((price - price1) / price1 * 100);
                            const sign = change > 0 ? '+' : '';
                            text = `${sign}${change.toFixed(2)}%`;
                            
                            if (Math.abs(change) < 0.01) color = '#d1d4dc';
                            else color = change >= 0 ? colors.up : colors.down;
                        } else {
                             color = '#2962FF';
                             text = `${(level * 100).toFixed(1)}%`;
                        }

                        let rightOffset = 0;
                        if (price !== null) {
                            const formatNum = (num) => num >= 1000 ? num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}) : (num >= 1 ? num.toFixed(4) : num.toPrecision(4));
                            const priceText = formatNum(price);
                            ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            const metrics = ctx.measureText(priceText);
                            rightOffset = metrics.width + 12; // padding * 2
                        }

                        ctx.fillStyle = color;
                        ctx.font = 'bold 12px Arial';
                        ctx.textAlign = 'right';
                        ctx.fillText(text, width - rightOffset - 5, y - 4);
                        ctx.textAlign = 'start';

                        if (price !== null) drawPriceLabel(price, y);
                    });
                } else if (drawing.type === 'parallel') {
                    if (points.length < 2) return;
                    const y1 = points[0].y;
                    const y2 = points[1].y;
                    const diff = y2 - y1;
                    const levels = drawing.levels || 2;
                    for (let i = -levels; i <= levels; i++) {
                        const y = y1 + diff * i;
                        ctx.beginPath();
                        ctx.lineWidth = (i === 0) ? 2 : 1;
                        ctx.setLineDash([]);

                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();

                        const price = candleSeries.coordinateToPrice(y);
                        if (price !== null) drawPriceLabel(price, y);
                    }
                }

                // Draw handles if tool matches
                if (currentTool.value === drawing.type && !overrideLastPoint) {
                    points.forEach(p => {
                        let hx = p.x;
                        if (['horizontal', 'fib', 'parallel'].includes(drawing.type)) {
                            hx = width / 2;
                        }
                        drawHandle(hx, p.y);
                    });
                }
            };

            drawings.forEach(d => drawShape(d));
            if (currentDrawing.value) {
                drawShape(currentDrawing.value, previewPoint);
            }
        };

        const initWorker = () => {
            const blob = new Blob([WORKER_CODE], { type: 'application/javascript' });
            indicatorWorker = new Worker(URL.createObjectURL(blob));
            indicatorWorker.onmessage = function(e) {
                const { id, type, results } = e.data;
                if (type === 'RESULT') applyIndicatorResults(results);
            };
        };

        const getColors = () => {
            const GREEN = '#26a69a', RED = '#ef5350', GREEN_TRANSPARENT = '#26a69a80', RED_TRANSPARENT = '#ef535080';
            return settings.colorScheme === 'green-up' 
                ? { up: GREEN, down: RED, upTransparent: GREEN_TRANSPARENT, downTransparent: RED_TRANSPARENT }
                : { up: RED, down: GREEN, upTransparent: RED_TRANSPARENT, downTransparent: GREEN_TRANSPARENT };
        };

        const initChart = () => {
            if (!chartRef.value) return;
            if (chart) { chart.remove(); chart = null; }
            
            allCandles = []; oldestTimestamp = null; newestTimestamp = null;
            hasMoreData = true; hasNewerData = true; isLoadingMore = false; isLoadingNewer = false;
            indicators.vol.series = null; indicators.ma.series = []; indicators.ema.series = [];
            indicators.boll.series = []; indicators.sar.series = []; indicators.supertrend.series = [];
            indicators.sr.series = []; indicators.subSeries = [];

            chart = LightweightCharts.createChart(chartRef.value, {
                layout: { background: { type: 'solid', color: '#131722' }, textColor: '#d1d4dc' },
                grid: { vertLines: { color: '#1e222d' }, horzLines: { color: '#1e222d' } },
                crosshair: { 
                    mode: LightweightCharts.CrosshairMode.Normal,
                    vertLine: {
                        width: 1,
                        style: 2,
                        visible: true,
                        labelVisible: true
                    },
                    horzLine: {
                        width: 1,
                        style: 2,
                        visible: true,
                        labelVisible: true
                    }
                },
                rightPriceScale: { borderColor: '#2a2e39' },
                timeScale: { borderColor: '#2a2e39', timeVisible: true, secondsVisible: false },
                width: chartRef.value.clientWidth, height: chartRef.value.clientHeight
            });

            const colors = getColors();
            if (currentBar.value === 'tick') {
                candleSeries = chart.addAreaSeries({ lineColor: '#2962FF', topColor: 'rgba(41, 98, 255, 0.3)', bottomColor: 'rgba(41, 98, 255, 0)', lineWidth: 2 });
            } else {
                candleSeries = chart.addCandlestickSeries({ upColor: colors.up, downColor: colors.down, borderDownColor: colors.down, borderUpColor: colors.up, wickDownColor: colors.down, wickUpColor: colors.up });
            }

            volumeSeries = chart.addHistogramSeries({ color: colors.up, priceFormat: { type: 'volume' }, priceScaleId: '' });
            volumeSeries.priceScale().applyOptions({ scaleMargins: { top: 0.8, bottom: 0 } });
            volumeSeries.applyOptions({ visible: indicators.vol.enabled });
            indicators.vol.series = volumeSeries;

            highlightSeries = currentBar.value !== 'tick' 
                ? chart.addCandlestickSeries({ upColor: 'transparent', downColor: 'transparent', borderUpColor: '#ffffff', borderDownColor: '#ffffff', wickUpColor: '#ffffff', wickDownColor: '#ffffff', borderVisible: true, priceLineVisible: false, lastValueVisible: false })
                : chart.addHistogramSeries({ color: 'rgba(255, 255, 255, 0.3)', priceFormat: { type: 'custom', formatter: () => '' }, priceScaleId: 'highlight_overlay', lastValueVisible: false, priceLineVisible: false });
            
            if (currentBar.value === 'tick') chart.priceScale('highlight_overlay').applyOptions({ scaleMargins: { top: 0, bottom: 0 }, visible: false });

            new ResizeObserver(entries => {
                if (entries.length === 0 || !chart) return;
                const { width, height } = entries[0].contentRect;
                chart.applyOptions({ width, height });
                if (drawingCanvas.value) {
                    drawingCanvas.value.width = width;
                    drawingCanvas.value.height = height;
                    renderDrawings();
                }
            }).observe(chartRef.value);

            chart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
                onVisibleRangeChange(range);
                renderDrawings();
            });
            chart.subscribeCrosshairMove(onCrosshairMove);
            chart.subscribeClick(onChartClick);

            if (drawingCanvas.value) {
                drawingCanvas.value.width = chartRef.value.clientWidth;
                drawingCanvas.value.height = chartRef.value.clientHeight;
            }
        };

        const loadCandlesticks = async (shouldFit = true) => {
            isLoading.value = true;
            try {
                const limit = 500;
                const response = await fetch(`/api/candlesticks/?symbol=${currentSymbol.value}&bar=${currentBar.value}&limit=${limit}&source=${currentSource.value}`);
                const result = await response.json();
                if (result.code === 0 && result.data) {
                    chartError.show = false;
                    const candles = result.data;
                    allCandles = candles;
                    if (candles.length > 0) {
                        oldestTimestamp = candles[0].time;
                        newestTimestamp = candles[candles.length - 1].time;
                        hasMoreData = candles.length >= limit;
                        hasNewerData = true;
                    } else hasMoreData = false;
                    updateChartData();
                    if (shouldFit) chart.timeScale().fitContent();
                    ensureEnoughHistoryData();
                } else showChartError('K线数据加载失败', result.error || '未知错误');
            } catch (err) { showChartError('无法连接到服务器', err.message); } 
            finally { isLoading.value = false; }
        };

        const updateChartData = () => {
            if (!chart || !candleSeries) return;
            const colors = getColors();
            const rate = getRate();

            if (currentBar.value === 'tick') {
                const lineData = allCandles.map(c => ({ 
                    time: c.time, 
                    value: (c.close !== undefined ? c.close : (c.price || c.value || 0)) * rate 
                }));
                candleSeries.setData(lineData);
            } else {
                const candleData = allCandles.map(c => ({
                    time: c.time,
                    open: c.open * rate,
                    high: c.high * rate,
                    low: c.low * rate,
                    close: c.close * rate
                }));
                candleSeries.setData(candleData);
            }
            
            if (indicators.vol.enabled && indicators.vol.series) {
                const volumeData = allCandles.map((c, i, arr) => {
                    let isUp = true;
                    if (c.open !== undefined && c.close !== undefined) isUp = c.close >= c.open;
                    else if (i > 0) {
                        const prev = arr[i-1];
                        const curr = c.close || c.price || c.value || 0;
                        const prevP = prev.close || prev.price || prev.value || 0;
                        isUp = curr >= prevP;
                    }
                    return { time: c.time, value: c.volume, color: isUp ? colors.upTransparent : colors.downTransparent };
                });
                indicators.vol.series.setData(volumeData);
            }
            triggerWorkerCalculation();
            updateNoDataOverlay();
            renderDrawings();
        };

        const triggerWorkerCalculation = () => {
            if (!indicatorWorker) initWorker();
            const activeIndicators = [];
            Object.keys(indicators).forEach(key => {
                if (key !== 'activeSubIndicator' && key !== 'subSeries' && indicators[key].enabled) activeIndicators.push(key);
            });
            if (indicators.activeSubIndicator !== 'none') activeIndicators.push(indicators.activeSubIndicator);
            if (activeIndicators.length > 0 && allCandles.length > 0) {
                const rate = getRate();
                const convertedCandles = allCandles.map(c => ({
                    ...c,
                    open: c.open * rate,
                    high: c.high * rate,
                    low: c.low * rate,
                    close: c.close * rate
                }));
                workerTaskCounter++;
                indicatorWorker.postMessage({ id: workerTaskCounter, type: 'CALCULATE', data: { candles: convertedCandles, indicators: activeIndicators } });
            }
        };

        const applyIndicatorResults = (results) => {
            ['ma', 'ema', 'boll', 'sar', 'supertrend', 'sr'].forEach(name => {
                if (results[name] && indicators[name].enabled) {
                    if (indicators[name].series.length === 0) createMainIndicatorSeries(name);
                    if (name === 'boll') {
                        indicators.boll.series[0].setData(results.boll.upper);
                        indicators.boll.series[1].setData(results.boll.middle);
                        indicators.boll.series[2].setData(results.boll.lower);
                    } else if (name === 'sr') {
                        indicators.sr.series[0].setData(results.sr.support);
                        indicators.sr.series[1].setData(results.sr.resistance);
                    } else if (name === 'ema') {
                        indicators.ema.series[0].setData(results.ema[0]);
                        indicators.ema.series[1].setData(results.ema[1]);
                        indicators.ema.series[2].setData(results.ema[2]);
                    } else if (name === 'ma') {
                        indicators.ma.series[0].setData(results.ma[0]);
                        indicators.ma.series[1].setData(results.ma[1]);
                        indicators.ma.series[2].setData(results.ma[2]);
                    } else indicators[name].series[0].setData(results[name]);
                }
            });

            if (indicators.activeSubIndicator !== 'none' && results[indicators.activeSubIndicator]) {
                const name = indicators.activeSubIndicator;
                const res = results[name];
                if (indicators.subSeries.length === 0) createSubIndicatorSeries(name);
                if (name === 'macd') {
                    indicators.subSeries[0].setData(res.histogram);
                    indicators.subSeries[1].setData(res.dif);
                    indicators.subSeries[2].setData(res.dea);
                } else if (name === 'kdj') {
                    indicators.subSeries[0].setData(res.k);
                    indicators.subSeries[1].setData(res.d);
                    indicators.subSeries[2].setData(res.j);
                } else if (name === 'stochrsi') {
                    indicators.subSeries[0].setData(res.k);
                    indicators.subSeries[1].setData(res.d);
                } else if (name === 'dmi') {
                    indicators.subSeries[0].setData(res.pdi);
                    indicators.subSeries[1].setData(res.mdi);
                    indicators.subSeries[2].setData(res.adx);
                } else if (name === 'dma') {
                    indicators.subSeries[0].setData(res.ddd);
                    indicators.subSeries[1].setData(res.ama);
                } else if (name === 'brar') {
                    indicators.subSeries[0].setData(res.ar);
                    indicators.subSeries[1].setData(res.br);
                } else indicators.subSeries[0].setData(res);
            }
        };

        const createMainIndicatorSeries = (name) => {
            if (name === 'ma') indicators.ma.series = [chart.addLineSeries({ color: '#E6E600', lineWidth: 1, title: 'MA7' }), chart.addLineSeries({ color: '#9C27B0', lineWidth: 1, title: 'MA25' }), chart.addLineSeries({ color: '#2196F3', lineWidth: 1, title: 'MA99' })];
            else if (name === 'ema') indicators.ema.series = [chart.addLineSeries({ color: '#FF9800', lineWidth: 1, title: 'EMA7' }), chart.addLineSeries({ color: '#00BCD4', lineWidth: 1, title: 'EMA25' }), chart.addLineSeries({ color: '#E91E63', lineWidth: 1, title: 'EMA99' })];
            else if (name === 'boll') indicators.boll.series = [chart.addLineSeries({ color: '#4CAF50', lineWidth: 1, title: 'BOLL Upper' }), chart.addLineSeries({ color: '#F44336', lineWidth: 1, title: 'BOLL Mid' }), chart.addLineSeries({ color: '#4CAF50', lineWidth: 1, title: 'BOLL Lower' })];
            else if (name === 'sar') indicators.sar.series = [chart.addLineSeries({ color: '#2962FF', lineWidth: 1, lineStyle: 2, title: 'SAR' })];
            else if (name === 'supertrend') indicators.supertrend.series = [chart.addLineSeries({ color: '#2962FF', lineWidth: 2, title: 'SuperTrend' })];
            else if (name === 'sr') indicators.sr.series = [chart.addLineSeries({ color: '#26a69a', lineWidth: 2, title: 'Support' }), chart.addLineSeries({ color: '#ef5350', lineWidth: 2, title: 'Resistance' })];
        };

        const createSubIndicatorSeries = (name) => {
            const subScaleId = 'sub';
            chart.priceScale(subScaleId).applyOptions({ scaleMargins: { top: 0.65, bottom: 0 } });
            if (name === 'macd') indicators.subSeries = [chart.addHistogramSeries({ priceScaleId: subScaleId, color: '#26a69a', lineWidth: 1, priceFormat: { type: 'volume' }, title: 'MACD Hist' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#2962FF', lineWidth: 1, title: 'DIF' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'DEA' })];
            else if (name === 'kdj') indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#2962FF', lineWidth: 1, title: 'K' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'D' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#E91E63', lineWidth: 1, title: 'J' })];
            else if (name === 'stochrsi') indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#2962FF', lineWidth: 1, title: 'K' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'D' })];
            else if (name === 'dmi') indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#26a69a', lineWidth: 1, title: '+DI' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#ef5350', lineWidth: 1, title: '-DI' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'ADX' })];
            else if (name === 'dma') indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#9C27B0', lineWidth: 1, title: 'DDD' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'AMA' })];
            else if (name === 'brar') indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#FF6D00', lineWidth: 1, title: 'AR' }), chart.addLineSeries({ priceScaleId: subScaleId, color: '#2962FF', lineWidth: 1, title: 'BR' })];
            else indicators.subSeries = [chart.addLineSeries({ priceScaleId: subScaleId, color: '#9C27B0', lineWidth: 1, title: name.toUpperCase() })];
        };

        const toggleMainIndicator = (name) => {
            if (name === 'vol') { if (indicators.vol.series) indicators.vol.series.applyOptions({ visible: indicators.vol.enabled }); }
            else {
                if (indicators[name].enabled) { if (indicators[name].series.length === 0) createMainIndicatorSeries(name); triggerWorkerCalculation(); }
                else { indicators[name].series.forEach(s => chart.removeSeries(toRaw(s))); indicators[name].series = []; }
            }
        };

        const switchSubIndicator = (name) => {
            if (indicators.subSeries.length > 0) { indicators.subSeries.forEach(s => chart.removeSeries(toRaw(s))); indicators.subSeries = []; }
            indicators.activeSubIndicator = name;
            if (name === 'none') chart.priceScale('right').applyOptions({ scaleMargins: { top: 0.1, bottom: 0.2 } });
            else { chart.priceScale('right').applyOptions({ scaleMargins: { top: 0.05, bottom: 0.4 } }); createSubIndicatorSeries(name); triggerWorkerCalculation(); }
        };

        const refreshData = (fitContent = false) => {
            if (!fitContent && allCandles.length > 0) updateLatestData();
            else loadCandlesticks(fitContent);
            loadTicker();
        };

        const updateLatestData = async () => {
            if (allCandles.length === 0) return;
            const lastCandle = allCandles[allCandles.length - 1];
            const lastTime = lastCandle.time;
            try {
                const response = await fetch(`/api/candlesticks/?symbol=${currentSymbol.value}&bar=${currentBar.value}&limit=5&source=${currentSource.value}`);
                const result = await response.json();
                if (result.code === 0 && result.data && result.data.length > 0) {
                    const newCandles = result.data;
                    let hasChanges = false;
                    const rate = getRate();
                    for (const newCandle of newCandles) {
                        if (newCandle.time === lastTime) {
                            if (newCandle.close !== lastCandle.close || newCandle.volume !== lastCandle.volume) {
                                allCandles[allCandles.length - 1] = newCandle;
                                if (currentBar.value === 'tick') candleSeries.update({ time: newCandle.time, value: newCandle.close * rate });
                                else candleSeries.update({
                                    time: newCandle.time,
                                    open: newCandle.open * rate,
                                    high: newCandle.high * rate,
                                    low: newCandle.low * rate,
                                    close: newCandle.close * rate
                                });
                                hasChanges = true;
                            }
                        } else if (newCandle.time > lastTime) {
                            allCandles.push(newCandle);
                            newestTimestamp = newCandle.time;
                            if (currentBar.value === 'tick') candleSeries.update({ time: newCandle.time, value: newCandle.close * rate });
                            else candleSeries.update({
                                    time: newCandle.time,
                                    open: newCandle.open * rate,
                                    high: newCandle.high * rate,
                                    low: newCandle.low * rate,
                                    close: newCandle.close * rate
                                });
                            hasChanges = true;
                        }
                    }
                    if (hasChanges) { triggerWorkerCalculation(); updateNoDataOverlay(); }
                }
            } catch (e) { console.error(e); }
        };

        const loadTicker = async () => {
            try {
                const response = await fetch(`/api/ticker/?symbol=${currentSymbol.value}&source=${currentSource.value}`);
                const result = await response.json();
                if (result.code === 0 && result.data) {
                    const t = result.data;
                    const rate = getRate();
                    const last = parseFloat(t.last) * rate;
                    const open = parseFloat(t.open24h) * rate;
                    ticker.last = last.toLocaleString();
                    ticker.changePercent = ((last - open) / open * 100).toFixed(2);
                    ticker.isUp = last >= open;
                    ticker.high24h = (parseFloat(t.high24h) * rate).toLocaleString();
                    ticker.low24h = (parseFloat(t.low24h) * rate).toLocaleString();
                    ticker.vol24h = parseFloat(t.vol24h).toLocaleString();
                }
            } catch (e) { console.error(e); }
        };

        const showChartError = (msg, detail) => { chartError.show = true; chartError.message = msg; chartError.detail = detail; };
        const retryLoad = () => { chartError.show = false; initChart(); refreshData(true); };
        const hideError = () => { error.show = false; };
        const toggleSettings = () => { settings.showModal = !settings.showModal; };
        const changeColorScheme = (scheme) => {
            settings.colorScheme = scheme;
            localStorage.setItem('geneticgrid_color_scheme', scheme);
            if (chart) {
                const colors = getColors();
                const root = document.documentElement;
                root.style.setProperty('--up-color', colors.up);
                root.style.setProperty('--down-color', colors.down);
                if (currentBar.value !== 'tick') candleSeries.applyOptions({ upColor: colors.up, downColor: colors.down, borderDownColor: colors.down, borderUpColor: colors.up, wickDownColor: colors.down, wickUpColor: colors.up });
                updateChartData();
            }
        };

        const changeCurrency = () => {
            localStorage.setItem('geneticgrid_currency', settings.currency);
            updateChartData();
            loadTicker();
        };
        
        const setBar = (bar) => { currentBar.value = bar; moreTimeframe.value = ''; showCustomInterval.value = false; initChart(); refreshData(true); };
        const handleMoreTimeframes = () => {
            if (moreTimeframe.value === 'custom') { showCustomInterval.value = true; nextTick(() => document.getElementById('custom-interval').focus()); }
            else { showCustomInterval.value = false; currentBar.value = moreTimeframe.value; initChart(); refreshData(true); }
        };
        const applyCustomInterval = () => {
            const val = customInterval.value.trim().toUpperCase();
            if (val && val.match(/^(\d+)([SMHDW])$/)) { currentBar.value = val.toLowerCase(); initChart(); refreshData(true); }
            else alert('格式错误！');
        };
        const toggleAutoRefresh = () => { isAutoRefresh.value = !isAutoRefresh.value; };

        const onVisibleRangeChange = (range) => {
            if (!range || allCandles.length === 0) return;
            if (hasMoreData && !isLoadingMore && range.from < 0) loadMoreHistory(Math.abs(Math.floor(range.from)) + 1000);
            else if (hasMoreData && !isLoadingMore && range.from < 1000) loadMoreHistory(1000);
            if (range.to > allCandles.length - 500 && hasNewerData && !isLoadingNewer) loadMoreNewerUntilEnough(range);
            updateNoDataOverlay();
        };
        
        const loadMoreHistory = async (count) => {
            if (isLoadingMore || !hasMoreData) return;
            isLoadingMore = true;
            try {
                const before = oldestTimestamp * 1000;
                const limit = Math.min(count, 2000);
                const res = await fetch(`/api/candlesticks/?symbol=${currentSymbol.value}&bar=${currentBar.value}&limit=${limit}&source=${currentSource.value}&before=${before}`);
                const result = await res.json();
                if (result.code === 0 && result.data && result.data.length > 0) {
                    const newC = result.data;
                    allCandles = [...newC, ...allCandles];
                    allCandles.sort((a, b) => a.time - b.time);
                    oldestTimestamp = allCandles[0].time;
                    updateChartData();
                } else hasMoreData = false;
            } catch (e) { console.error(e); }
            finally { isLoadingMore = false; }
        };
        
        const loadMoreNewerUntilEnough = async () => {
            if (isLoadingNewer || !hasNewerData) return;
            isLoadingNewer = true;
            let loadedCount = 0;
            try {
                while (hasNewerData && loadedCount < 2000) {
                    const afterTs = newestTimestamp * 1000;
                    const res = await fetch(`/api/candlesticks/?symbol=${currentSymbol.value}&bar=${currentBar.value}&limit=500&source=${currentSource.value}&after=${afterTs}`);
                    const result = await res.json();
                    if (result.code === 0 && result.data && result.data.length > 0) {
                        const newC = result.data;
                        const existingTimes = new Set(allCandles.map(c => c.time));
                        const unique = newC.filter(c => !existingTimes.has(c.time));
                        if (unique.length > 0) {
                            allCandles = [...allCandles, ...unique];
                            allCandles.sort((a, b) => a.time - b.time);
                            newestTimestamp = allCandles[allCandles.length - 1].time;
                            loadedCount += unique.length;
                            updateChartData();
                        } else { hasNewerData = false; break; }
                        if (newC.length < 500) { hasNewerData = false; break; }
                    } else { hasNewerData = false; break; }
                }
            } catch (e) { console.error(e); }
            finally { isLoadingNewer = false; }
        };

        const ensureEnoughHistoryData = () => { if (allCandles.length < 1000) loadMoreHistory(1000); };
        const updateNoDataOverlay = () => {
            const overlay = document.getElementById('no-data-overlay');
            if (!overlay || !chart) return;
            if (!hasMoreData && allCandles.length > 0) {
                const x = chart.timeScale().timeToCoordinate(allCandles[0].time);
                if (x !== null && x > 0) { overlay.style.display = 'flex'; overlay.style.width = `${x}px`; }
                else overlay.style.display = 'none';
            } else overlay.style.display = 'none';
        };
        
        const onCrosshairMove = (param) => {
            if (currentTool.value !== 'cursor') {
                handleDrawingMove(param);
            }
            const tooltip = document.getElementById('candle-tooltip');
            if (!tooltip) return;
            if (isTooltipLocked) return;
            if (!param || !param.time || param.point === undefined || param.point.x < 0 || param.point.y < 0) { tooltip.style.display = 'none'; return; }
            updateTooltipContent(param);
        };
        
        const onChartClick = (param) => {
            if (currentTool.value === 'delete') {
                if (!param || !param.point) return;
                handleDeleteClick(param.point);
                return;
            }
            if (currentTool.value !== 'cursor') {
                handleDrawingClick(param);
                return;
            }
            if (!param || !param.time) {
                isTooltipLocked = false; lockedCandleTime = null;
                document.getElementById('candle-tooltip').classList.remove('locked');
                if (highlightSeries) highlightSeries.setData([]);
                return;
            }
            const candleData = param.seriesData.get(candleSeries);
            if (!candleData) return;
            if (isTooltipLocked && lockedCandleTime === param.time) {
                isTooltipLocked = false; lockedCandleTime = null;
                document.getElementById('candle-tooltip').classList.remove('locked');
                if (highlightSeries) highlightSeries.setData([]);
            } else {
                isTooltipLocked = true; lockedCandleTime = param.time;
                document.getElementById('candle-tooltip').classList.add('locked');
                if (highlightSeries) {
                    if (currentBar.value !== 'tick') highlightSeries.setData([{ time: param.time, open: candleData.open, high: candleData.high, low: candleData.low, close: candleData.close }]);
                    else highlightSeries.setData([{ time: param.time, value: 1, color: 'rgba(255, 255, 255, 0.3)' }]);
                }
                updateTooltipContent(param);
            }
        };
        
        const updateTooltipContent = (param) => {
            const tooltip = document.getElementById('candle-tooltip');
            if (!tooltip) return;
            const candleData = param.seriesData.get(candleSeries);
            const volumeData = param.seriesData.get(volumeSeries);
            if (!candleData) { if (!isTooltipLocked) tooltip.style.display = 'none'; return; }
            
            const date = new Date(param.time * 1000);
            const timeStr = date.toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: currentBar.value === 'tick' ? '2-digit' : undefined });
            
            let open, high, low, close;
            if (currentBar.value === 'tick') { close = candleData.value; open = close; high = close; low = close; }
            else { open = candleData.open; high = candleData.high; low = candleData.low; close = candleData.close; }
            
            let change = 0, changePercent = "0.00", isUp = true;
            if (currentBar.value !== 'tick') { change = close - open; changePercent = ((change / open) * 100).toFixed(2); isUp = change >= 0; }
            const colorClass = isUp ? 'up' : 'down';
            const formatNum = (num) => num >= 1000 ? num.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2}) : (num >= 1 ? num.toFixed(4) : num.toPrecision(4));
            const formatVolume = (vol) => vol >= 1e9 ? (vol / 1e9).toFixed(2) + 'B' : (vol >= 1e6 ? (vol / 1e6).toFixed(2) + 'M' : (vol >= 1e3 ? (vol / 1e3).toFixed(2) + 'K' : vol.toFixed(2)));
            
            const timeEl = document.getElementById('tooltip-time');
            const openEl = document.getElementById('tooltip-open');
            const highEl = document.getElementById('tooltip-high');
            const lowEl = document.getElementById('tooltip-low');
            const closeEl = document.getElementById('tooltip-close');
            const changeEl = document.getElementById('tooltip-change');
            const volumeEl = document.getElementById('tooltip-volume');
            const rowOpen = document.getElementById('row-open');
            const rowHigh = document.getElementById('row-high');
            const rowLow = document.getElementById('row-low');
            
            if (!timeEl || !openEl || !highEl || !lowEl || !closeEl || !changeEl || !volumeEl) return;
            timeEl.textContent = timeStr;
            
            if (currentBar.value === 'tick') {
                if (rowOpen) rowOpen.style.display = 'none';
                if (rowHigh) rowHigh.style.display = 'none';
                if (rowLow) rowLow.style.display = 'none';
                const closeLabel = closeEl.previousElementSibling;
                if (closeLabel) closeLabel.textContent = '价格';
                const changeRow = changeEl.parentElement;
                if (changeRow) changeRow.style.display = 'none';
            } else {
                if (rowOpen) rowOpen.style.display = 'flex';
                if (rowHigh) rowHigh.style.display = 'flex';
                if (rowLow) rowLow.style.display = 'flex';
                const closeLabel = closeEl.previousElementSibling;
                if (closeLabel) closeLabel.textContent = '收盘';
                const changeRow = changeEl.parentElement;
                if (changeRow) changeRow.style.display = 'flex';
                openEl.textContent = formatNum(open);
                highEl.textContent = formatNum(high);
                lowEl.textContent = formatNum(low);
                changeEl.textContent = `${isUp ? '+' : ''}${changePercent}%`;
                changeEl.className = `tooltip-value ${colorClass}`;
            }
            closeEl.textContent = formatNum(close);
            closeEl.className = `tooltip-value ${colorClass}`;
            const volume = volumeData ? volumeData.value : (candleData.volume || 0);
            volumeEl.textContent = formatVolume(volume);
            tooltip.style.display = 'block';
        };

        const getHandleAtPoint = (point) => {
            const threshold = 6;
            const width = drawingCanvas.value ? drawingCanvas.value.width : 0;

            for (let i = drawings.length - 1; i >= 0; i--) {
                const d = drawings[i];
                if (currentTool.value !== d.type) continue;
                
                for (let j = 0; j < d.points.length; j++) {
                    const p = logicalToPoint(d.points[j]);
                    if (p) {
                        let hx = p.x;
                        if (['horizontal', 'fib', 'parallel'].includes(d.type)) {
                            hx = width / 2;
                        }
                        
                        if (Math.hypot(hx - point.x, p.y - point.y) < threshold) {
                            return { drawing: d, pointIndex: j };
                        }
                    }
                }
            }
            return null;
        };

        const handleContainerMouseMove = (e) => {
            if (draggingState.isDragging) return;
            if (!drawingCanvas.value) return;
            
            const rect = drawingCanvas.value.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const handle = getHandleAtPoint({x, y});
            if (handle) {
                drawingCanvas.value.style.pointerEvents = 'auto';
                drawingCanvas.value.style.cursor = 'move';
            } else {
                drawingCanvas.value.style.pointerEvents = 'none';
                drawingCanvas.value.style.cursor = 'default';
            }
        };

        const handleCanvasMouseDown = (e) => {
            if (!drawingCanvas.value) return;
            const rect = drawingCanvas.value.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const handle = getHandleAtPoint({x, y});
            
            if (handle) {
                draggingState.isDragging = true;
                draggingState.drawing = handle.drawing;
                draggingState.pointIndex = handle.pointIndex;
                e.preventDefault();
                e.stopPropagation();
            }
        };

        const handleWindowMouseMove = (e) => {
            if (!draggingState.isDragging || !draggingState.drawing) return;
            if (!drawingCanvas.value) return;
            
            const rect = drawingCanvas.value.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const logical = pointToLogical({x, y});
            if (logical) {
                draggingState.drawing.points[draggingState.pointIndex] = logical;
                renderDrawings();
            }
        };

        const handleWindowMouseUp = () => {
            if (draggingState.isDragging) {
                draggingState.isDragging = false;
                draggingState.drawing = null;
                draggingState.pointIndex = -1;
            }
        };

        onMounted(() => {
            initChart();
            refreshData(true);
            fetchExchangeRates();
            refreshInterval = setInterval(() => { if (isAutoRefresh.value) refreshData(false); }, 2000);
            changeColorScheme(settings.colorScheme);

            if (drawingCanvas.value) {
                drawingCanvas.value.addEventListener('mousedown', handleCanvasMouseDown);
            }
            window.addEventListener('mousemove', handleWindowMouseMove);
            window.addEventListener('mouseup', handleWindowMouseUp);
            
            if (chartRef.value && chartRef.value.parentElement) {
                chartRef.value.parentElement.addEventListener('mousemove', handleContainerMouseMove);
            }
        });

        onUnmounted(() => {
            if (refreshInterval) clearInterval(refreshInterval);
            if (chart) chart.remove();
            if (indicatorWorker) indicatorWorker.terminate();

            if (drawingCanvas.value) {
                drawingCanvas.value.removeEventListener('mousedown', handleCanvasMouseDown);
            }
            window.removeEventListener('mousemove', handleWindowMouseMove);
            window.removeEventListener('mouseup', handleWindowMouseUp);
            if (chartRef.value && chartRef.value.parentElement) {
                chartRef.value.parentElement.removeEventListener('mousemove', handleContainerMouseMove);
            }
        });

        return {
            currentSymbol, currentBar, currentSource, isAutoRefresh, isLoading,
            ticker, error, chartError, indicators, settings,
            moreTimeframe, customInterval, showCustomInterval,
            mainIndicatorsConfig, subIndicatorsConfig,
            chartRef,
            refreshData, toggleMainIndicator, switchSubIndicator,
            toggleSettings, changeColorScheme, changeCurrency, hideError, retryLoad,
            setBar, handleMoreTimeframes, applyCustomInterval, toggleAutoRefresh,
            drawingCanvas, currentTool, setTool, clearDrawings, isDrawingToolbarExpanded, parallelLevels, showToolSettings, toggleDeleteMode
        };
    }
}).mount('#app');
</script>